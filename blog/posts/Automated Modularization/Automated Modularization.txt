<!-- wp:paragraph -->
<p>This post is similar to <a href="https://thomasjporter.wordpress.com/morphic-programming/">my last</a>, on what I called morphic programming, in that it is a pie-in-the-sky, uninformed daydream about a possible feature of computer programming paradigms. This idea arose out of the redundancy between different programming languages, and within programming languages between different projects. Different languages are used for different purposes, including specialized collections and levels of abstractions, and different projects using the same language are even more obviously divergent. But for almost every programming language, the functionality relating to arithmetic, logic, strings, arrays, etc. must be independently implemented. Within languages, plenty of functions, data structures, and classes are common enough to appear frequently in projects without being implemented in the base language or a library.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This issue is precisely a mismatch between the distribution of implementations of 'modularizations' (which I use to mean pieces of code packaged into units like functions, data structures, or classes) and the distribution of their uses. I envision an improvement along the lines of automated modularization, which would consist of a base layer of expression (like machine code, a simple imperative language, lambda calculus, or even something morphic), and an adaptive system which automatically packages common pieces of code into modules. This idea is, in fact, essentially automatic language definition, modulo choosing syntax, since it takes a base layer of expression as a semantics and automatically identifies the most useful higher-level entities.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This project might begin by collecting as much real world code as possible, translating that code into the chosen lowest level of abstraction, and producing a list of modularizations (function, data structure, or class definitions) according to some optimization principle. This principle ought to balance such aims as:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>minimizing the expected length of a program written with all available modules</li><li>maximizing the expected length reduction from the program written the lowest level to the program written with all available modules</li><li>bounding of the number of modularizations</li><li>bounding from below the computational 'distance' between different modularizations, so as to minimize their redundancy</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>The full formulation of what should be optimized would surely be very subtle, as evidenced by the simultaneous necessity and opposition of the above principles, but in any case would probably have something to do with maximizing the entropy that each keyword would convey within each program. This makes me wonder if the process of automatic modularization might resemble a decision tree algorithm in classification problems. I also think this notion of automatic, optimized language definition on a low level semantics holds striking parallels to the notion of automatic extraction of effective theories about a fundamental system.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The goal of such a system is for programmers to be able to write at whatever level of abstraction is intuitive to them, with an organic cooperation between individual projects and the automated system as a whole. Each new project (if the creators should permit its use for updating the language) could inform slight adjustments or additions to the language, and each time a programmer writes, or starts to write, the code of a module that has already been identified, the IDE could suggest the use of this module. In this way, the programmer could gradually learn more and more about the range of possible modules, which would far exceed that of the core languages we use now. The number of modules included in the workspace of a programmer could vary by the amount of space manually allocated, or automatically by what appears to be relevant to the programmer. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Like with morphic programming, the feasibility of such a system relies on a very smart machine, which would do much more decision making than we currently have our machines do, in the area of programming languages. These dreams arise from looking towards the future, towards what would be optimal for human use, within what is possible for computer performance, rather than what is acceptable for human use, within what is plausible for computer performance.</p>
<!-- /wp:paragraph -->